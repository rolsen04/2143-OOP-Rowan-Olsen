# ðŸ§  OOP Worksheet & Study Guide  
## Making Types That Feel Native

Due: 16 Feb 2026  

---

# Part 0 â€” Reality Check

Most people think:

OOP = inheritance  

Thatâ€™s wrong.

Inheritance is one tool.  
Itâ€™s not the point.

This worksheet is about building types that behave correctly and predictably â€” not building class hierarchies for fun.

---

# Part 1 â€” Stacks & Queues

## Array vs List Implementations

### Memory Layout

- **Array-based:** Contiguous memory.
- **List-based:** Nodes scattered in memory, linked with pointers.

That difference matters.

---

### Resizing Behavior

- **Array-based:** Fixed capacity. When full, allocate a bigger array and copy everything.
- **List-based:** Allocates one node at a time. No large copy.

---

### Cache Friendliness

- **Array-based:** Excellent cache locality. Fast in practice.
- **List-based:** Poor cache behavior. Pointer chasing hurts performance.

Yes, this matters.

---

## Why is `std::vector` good for a stack but bad for a queue?

A stack pushes and pops from the back.  
`std::vector` is efficient at the back.

A queue removes from the front.  
Removing the first element in a vector shifts everything. Thatâ€™s O(n).

So vector fits stacks naturally. Not queues.

---

## Invariants

**Stack:**  
Only the most recently inserted element can be removed. (LIFO)

**Queue:**  
The earliest inserted element not yet removed must be removed next. (FIFO)

If this rule breaks, the structure is wrong.

---

# Part 2 â€” Overloading vs Overriding

| Feature | Overloading | Overriding |
|----------|-------------|------------|
| Resolved at | Compile time | Runtime |
| Requires inheritance | No | Yes |
| Same function name | Yes | Yes |
| Same parameter list | No | Yes |
| Polymorphism | Static | Dynamic |

---

### Why is overloading a compile-time convenience?

The compiler decides which function to call based on parameters.  
Itâ€™s resolved before the program runs. No runtime cost.

---

### Why is overriding a runtime contract?

Overriding depends on virtual functions.  
The correct function is chosen at runtime based on the objectâ€™s actual type.

Thatâ€™s real polymorphism.

---

### Why do beginners confuse them?

Same word root. Same function names.  
Different mechanics.

---

### Why is that dangerous?

You forget `virtual`.  
You expect runtime behavior that never happens.  
The compiler does exactly what you told it â€” not what you meant.

---

# Part 3 â€” Constructors & Initialization Lists

## Initialization Lists

Given:

```cpp
class Widget {
private:
    const int id;
    std::string name;

public:
    Widget(int id, std::string name);
};
```

### Why must this use an initialization list?

Because `id` is `const`.  
Const members must be initialized when the object is created.  
You cannot assign to them later.

---

### What happens if you assign inside the constructor body?

Compilation error.  
Youâ€™re trying to modify a const member.

---

### Correct constructor

```cpp
Widget(int id, std::string name)
    : id(id), name(name) {}
```

---

### Other cases requiring initialization lists

- Reference members  
- Base class constructors  

---

## Copy Constructor vs Assignment Operator

### Copy constructor is called when:

A new object is created from another object.

```cpp
Point2D b = a;
```

---

### Assignment operator is called when:

An existing object is assigned a new value.

```cpp
Point2D b;
b = a;
```

---

### Why both exist?

Construction initializes memory.  
Assignment replaces existing state.

Different lifecycle stages. Different responsibilities.

---

### What goes wrong if you confuse them?

- Memory leaks  
- Double frees  
- Shallow copy bugs  
- Broken resource ownership  

---

# Part 4 â€” struct vs class

### Only language-level difference?

Default access:

- `struct` â†’ public  
- `class` â†’ private  

Thatâ€™s it.

---

### Why have both?

To signal intent.

`struct` â†’ plain data  
`class` â†’ abstraction with invariants  

---

### When is `struct` better?

When the type is just data with no strict invariants.

---

### Why does intent matter?

In large systems, clarity prevents misuse.  
Code is read more than it is written.

---

# Part 5 â€” Operator Overloading

## Why canâ€™t C++ overload `.`, `::`, or `sizeof`?

Theyâ€™re fundamental language operators tied to compile-time behavior.  
Letting you overload them would break the language model.

---

## Why should `operator+` not mutate the left operand?

`+` represents value addition.  
Users expect it to return a new value.

Mutation belongs in `+=`.

---

## Why is `operator<<` almost never a member?

Because the left operand is `std::ostream`.  
You canâ€™t modify `std::ostream`, so the operator must be non-member.

---

# The rhs Trap

Given:

```cpp
Point operator+(const Point& rhs) const;
```

### Who owns this function?

The left-hand operand.

---

### What is `rhs`?

The right-hand operand.

---

### How can it access private members?

Objects of the same class can access each otherâ€™s private members.

Access control is class-based â€” not object-based.

---

# Part 6 â€” friend

### What does `friend` actually do?

It gives a function or class access to private members.

---

### Why is `operator<<` often a friend?

It needs private data but must be a non-member function.

---

### Why is excessive use a red flag?

It weakens encapsulation.  
If everything is a friend, nothing is private.

---

### Legitimate use case

Stream insertion operator.

### Illegitimate use case

Using `friend` just to avoid designing a proper interface.

---

# Part 7 â€” Core Programming Task

## Point2D Implementation

```cpp
#include <iostream>

class Point2D {
private:
    double x;
    double y;

public:
    Point2D() : x(0), y(0) {}

    Point2D(double x, double y) : x(x), y(y) {}

    Point2D(const Point2D& other) : x(other.x), y(other.y) {}

    Point2D operator+(const Point2D& rhs) const {
        return Point2D(x + rhs.x, y + rhs.y);
    }

    Point2D operator-(const Point2D& rhs) const {
        return Point2D(x - rhs.x, y - rhs.y);
    }

    bool operator==(const Point2D& rhs) const {
        return x == rhs.x && y == rhs.y;
    }

    bool operator!=(const Point2D& rhs) const {
        return !(*this == rhs);
    }

    friend std::ostream& operator<<(std::ostream& os, const Point2D& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};
```

---

### Required Usage

```cpp
Point2D a(3, 4);
Point2D b(1, 2);

Point2D c = a + b;
Point2D d = a - b;

if (c == Point2D(4, 6)) {
    std::cout << "Math still works.\n";
}

std::cout << a << std::endl;
```

---

# Part 8 â€” Composition

Composition means â€œhas-a.â€  
Inheritance means â€œis-a.â€

Most systems care more about capability than identity.

Use inheritance when identity matters.  
Use composition when behavior matters.

Composition is usually safer.

---

# Part 9 â€” Reflection

### Does Point2D feel like a built-in type?

Yes. It supports arithmetic, comparison, and streaming naturally.

---

### What contributed most?

Const correctness and returning new objects from operators.

---

### What concept feels overhyped?

Inheritance.

---

### What feels underrated?

Encapsulation and const correctness.

---

### What was uncomfortable?

Designing operators without breaking expectations.  
It forces you to think about behavior, not just syntax.
